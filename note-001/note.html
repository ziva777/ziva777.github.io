<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="preconnect" href="https://fonts.googleapis.com"> 
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
<link href="https://fonts.googleapis.com/css2?family=Lora&family=Open+Sans&display=swap" rel="stylesheet">
<style>

body {
	display: flex;
	flex-direction: column;
	font-size: 16px;
	font-family: 'Open Sans', sans-serif;
	line-height: 1.5;
}

h1, h2, h3, h4, h5 { color: #000000; }
h1 { font-size: 28px; }
h2 { font-size: 24px; }
h3 { font-size: 20px; }
h4 { font-size: 16px; }
h5 {
	font-size: 14px;
	margin: 0px;
}

.num { color: #cfd8dc; }

.illustration {
	color: #62727b;
	font-size: 14px;
	text-align: center;/
	margin: 0px;
	font-style: oblique;
}

.content {
	max-width: 975px;
	margin: auto;
}

/* full width container */
.grid-container {
	position: relative;
	left: -38px; /* 75px / 2 */
	display: grid;
	grid-template-columns: 75px 900px;
	gap: 0px;
	padding: 0px;
}

.grid-container > div {
	text-align: left;
	padding: 0px 0;
}

/* 1:1 container */
.grid-container-1-1 {
	display: grid;
	grid-template-columns: 425px 425px;
	gap: 50px;
	padding: 0px;
}

.grid-container-1-1 > div {
	text-align: left;
	padding: 0px 0;
}

/* 1:2 container */
.grid-container-1-2 {
	display: grid;
	grid-template-columns: 275px 575px;
	gap: 50px;
	padding: 0px;
}

.grid-container-1-2 > div {
	text-align: left;
	padding: 0px 0;
}

.just {
	align: justify;
}

</style>

<!-- DOCUMENT CAPTION -->

<body lang="en">
<div class="content">
<div class="grid-container">

<!-- DOCUMENT BEGIN -->

<div> <!-- para -->
</div>
<div>
<h1>Устройство 64-битных счётчиков транзакций в Postgres Pro Enterprice</h1>
<h2>Введение</h2>
</div>

<div><p class="num">1</p></div>
<div><p>
Эта статья описывает реализацию 64-битных счётчиков транзакций (<i>XID, ксидов</i>) в СУБД Postgres Pro Enterprise, которая создана на основе свободной, опенсорсной объектно–реляционной СУБД Postgres.
Она ориентирована на тех, кто имеет практический опыт в работе с СУБД Postgres Pro Enterprise, но будет интересна и тем, кто интересуется развитием СУБД Postgres, так как описывает сравнение этих двух систем.
Статья также описывает устройство таблиц на диске и организацию формата хранения данных отношений.
</p></div>

<div><p class="num">2</p></div>
<div><p>
Postrges старается быть максимально гибким в конфигурации, чтобы удовлетворить запросы как можно большего числа своих пользователей. 
Большинство параметров, например, таких как: размер страницы BLCKSZ (по умолчанию 8 кБ), размер сегмента SEGSIZE (по умолчанию 1 Гб), могут быть изменены при сборке Postgres.
</p></div>

<div><p class="num">3</p></div>
<div><p>
Хотелось бы сразу обозначить, что мы будем рассматривать 64-х битный вариант сборки Postrges, в котором все параметры имеют значение по умолчанию.
Также мы не будем углубляться в мультитранзакции.
Для целей этой статьи будет достаточным предположения,что они в данном контексте аналогичны "обычным" транзакциям.
</p></div>

<div><p class="num">47</p></div>
<div><p>
Мы выложили наш вариант реализации в сообщество, а также занимаемся активным продвижением его в сообществе разработчиков Postgres.
Он не на 100% идентичен коду, используемому в Postgres Pro Enterprice (в частности, там ксиды всё ещё образуют кольцо), но общая идея такая же, как изложена в статье.
На текущий момент патч ожидает ревью.
Мы надеемся, что он станет частью Postgres и верим, что это сделает его значительно лучше.
Тем не менее, по этому вопросу предстоит ещё много работы. Поэтому мы будем благодарны всем желающим и небезразличным за посильное участие в его развитии.
</p></div>

<div> <!-- para -->
</div>
<div>
<h2>1. Счётчики транзакций</h2>
</div>

<div><p class="num">4</p></div>
<div><p>
Рассмотрим подробнее: для чего они нужны в Postrges и какие проблемы могут возникать при их использовании.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>1.1. Кратко об MVCC</h3>
</div>

<div><p class="num">5</p></div>
<div><p>
Сложилось такое мнение, что базы данных - это механизм хранения данных, но это не совсем верно.
Базы данных не только дают возможность хранения данных, но и обеспечивают согласованный и непротиворечивый и чаще всего многопользовательский доступ к этим данным.
И именно это их свойство позволяет нам организовывать сложные многопользовательские системы хранения и обработки данных.
Для тех, кто глубоко интересуется этой темой, можно упомянуть, что в основе работы большинства реляционных СУБД лежит набор свойств, известный как ACID.
К таким СУБД относится и Postgres.
Требования ACID накладывают на транзакционную систему, которой, безусловно является СУБД, ряд требований: атомарность, согласованность, изоляция и устойчивость.
К сожалению, обсуждение этих принципов не является целью сегодняшней статьи, так что придётся оставить его за рамками изложения.
Но интересующиеся либо уже знают про них, либо могут легко с ними ознакомиться, благо информации по этой тематике предостаточно, в том числе и в свободном доступе.
Например, в книге Егора Рогова "PostgreSQL изнутри", которая имеется в свободном доступе. [1]
</p></div>


<div> <!-- para -->
</div>
<div>
<h3>1.2. Как MVCC реализовано в Postgres</h3>
</div>

<div><p class="num">6</p></div>
<div><p>
В Postgres используется многоверсионный вариант протокола изоляции на основе снимков.
Такой механизм позволяет обходиться минимальным количеством блокировок.
Фактически блокируется только повторное изменение одной и той же строки. 
Все остальные операции могут выполняться обновременно: пишущие транзакции никогда не блокируют читающие транзакции, а читающие вообще никогда никого не блокируют. [3]
</p></div>

<div><p class="num">7</p></div>
<div><p>
Данные в Postgres хранятся в виде кортежей (они же строки или записи) с добавлением некоторой служебной информации.
Каждая транзакция в PostgreSQL имеет свой номер (идентификатор), называемый xid, который явлется простым, 32–х битным счётчиком. [5]
Каждая строчка в таблице, в свою очередь, имеет, помимо прочего, два дополнительных системных поля, которые не показываются в запросах пользователей: они называются xmin и xmax.
Поле xmin хранит номер транзакции, которая создала данную строку, а xmax — номер транзакции, которая её удалила (если, конечно, такое произошло).
Таким образом, каждая строчка может иметь несколько версий с разной областью видимости.
Такой подход к организации хранения данных называется версионным. [4]
</p></div>

<div><p class="num">8</p></div>
<div><p>
Отдельно появляется вопрос: как определить какая транзакция следует за какой?
Казалось бы, в чём может быть проблема? Если счётчик транзакций (xid) - это простое беззнаковое 32–х битное число, то это значит, что какой xid меньше, такой и был создан раньше, значит он и старше.
Когда-то так и было.
Но при достижении максимального значения счётчика транзакции СУБД нужно было останавливать и создавать из дампа заново.
</p></div>

<div><p class="num">9</p></div>
<div><p>
К счастью, эти времена давно ушли. Сегодня используется механизм xid wraparround, который позволяет на работающем кластере запустить счётчик вновь с минимальным
номером транзакции (как ни странно, но это номер 3, так как значения 0-2 зарезервированы для служебных целей) без пересоздания БД. Также вы можете ознакомиться с этим механизмом в статье "Различия  Postgres Pro Enterprise и PostgreSQL" в пункте 2 [7].
Однако платить за это приходится более сложным подходом к вычислению возраста транзакций, а также необходимостью запуска вакуума в нужный момент времени.
</p></div>

<div><p class="num">10</p></div>
<div><p>
Итак, в начале каждой транзакции создаётся соответствующий уникальный идентификатор.
Его можно вывести, используя функцию <code>txid_current()</code>.
Но при этом для транзакций не стоит использовать понятия "больше" и "меньше".
Лучше использовать понятия "старше" и "младше".
И вот почему: номера транзакций (xid) сравниваются друг с другом по модулю 2^32, то есть образуют кольцо.
Все транзакции, отстоящие от текущей в сторону минуса на 2^31, считаются "в прошлом", а отстоящие на 2^31 в положительную сторону находятся "в будущем".
</p></div>

<div><p class="num">11</p></div>
<div><p>
Графически это обычно изображается следующим образом:
</p></div>
<div><p class="num"></p></div>
<div>
<img width="800" src="./img/01.svg">
<p class="illustration">Рис. 1 – счётчики транзакций в Postgres</p></div>

<div> <!-- para -->
</div>
<div>
<h3>1.3. Основные проблемы существующего решения</h3>
</div>

<div><p class="num">12</p></div>
<div><p>
Когда проектировался Postgres, количество транзакций в 4 миллиарда справедливо казалось огромным.
Однако в современных реальных условиях эксплуатации Postgres приходится сталкиваться с тем, что xid wraparound может наступить за три и даже за два дня (!)
</p></div>

<div><p class="num">13</p></div>
<div><p>
В таких условиях критичными становятся два фактора: отсутствие долгих ("висящих") транзакций в БД и корректная работа вакуума (vacuum freeze, если быть точным).
Если учесть, что при описанной выше транзакционной нагрузке работа последнего может занимать до дня времени, работа по администрированию
Postgres в таких случаях становится довольно непростой. Достаточно упустить момент, и база будет остановлена.
</p></div>

<div><p class="num">14</p></div>
<div><p>
В сообществе Postgres недавно обсуждался вопрос: является ли xid wraparound проблемой или нет.
В целом, непосредственно сам механизм работает корректно и не является проблемой.
Более того, в идеальном мире, где все механизмы отстроены и не дают сбоев, можно жить и с существующим решением.
Однако для корректной работы Postgres в такой ситуации высокой транзакционной нагрузки нужна корректная работа нескольких разных механизмов (вакуум и xid wraparound),
постоянный мониториг параметров (например, самой старой транзакции) и незамедлительная реакция в случае роста разницы между
самой старой транзакцией и самой новой.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>1.4. Переход на 64–х битные транзакции</h3>
</div>

<div><p class="num">15</p></div>
<div><p>
Переход на 64–х битные транзакции в случае высокой транзакционной нагрузки даст гораздо большую свободу администраторам БД.
Конечно, он не отменяет обязательную работу вакуума, как и необходимость слежки за долгими транзакциями и возрастом самой старой транзакции.
Но он сможет сделать эту работу не такой напряжённой, дав больший запас времени и простор "для манёвра".
</p></div>

<div><p class="num">16</p></div>
<div><p>
Идея перехода на 64–х битные счётчики транзакций находит положительный отклик в сообществе разработчиков Postgres.
Понимание этого важного шага уже давно пришло к людям.
Вопрос только в его конкретной реализации.
</p></div>

<div><p class="num">17</p></div>
<div><p>
Другой интересный факт, что при этом можно будет отказаться от механизма кольца ксидов по модулю 2^32.
Расчёты показывают, что даже при транзакционной нагрузке, при которой 32–х битные ксиды переполняются за два дня, в случае 
64–х битных транзакций понадобятся сотни лет чтобы счётчик исчерпался.
Именно так поступили в Postgres Pro Enterprise: в нём ксиды не образуют кольца, при этом используется  сравнение на "больше" и "меньше",
чтобы понять какая транзакция старше, а какая младше.
</p></div>

<div> <!-- para -->
</div>
<div>
<h2>2. Варианты реализации 64–х битных счётчиков транзакций</h2>
</div>

<div><p class="num">18</p></div>
<div><p>
Предлагаем следующие варианты реализации 64–х битных счётчиков транзакций в Postgres:
<ol>
    <li>"честные 64–х битные ксиды": замена всех счётчиков транзакций на 64–х битные;</li>
    <li>"через метод доступа": изменить формат страниц для конкретных таблиц, для которых пользователь считает это нужным;</li>
    <li>"хранение базы": для каждой страницы хранить некоторое смешение, относительно которого все ксиды на страницы должны быть вычислены.</li>
  </ol>
</p></div>

<div><p class="num">19</p></div>
<div><p>
Каждое из этих решений имеет как свои плюсы, так и минусы.
В СУБД Postgres Pro Enterprise используется третий вариант, как самый компромиссный их всех.
С одной стороны, он не требует значительного изменения формата страницы Postgres, фактически, оставляя формат кортежей на странице в оригинальном формате,
с другой - нет значительного роста в занимаемом дисковом пространстве.
</p></div>

<div> <!-- para -->
</div>
<div>
<h2>3. Размещение на диске</h2>
</div>

<div><p class="num">20</p></div>
<div><p>
Прежде, чем приступить к особенностям реализации 64–х битных счётчиков транзакций в СУБД Postgres Pro Enterprise, нужно разобраться в том, как хранит данные таблиц PostgreSQL.
И только после этого можно будет через сравнение понять: в чем заключается отличие СУБД Postgres от Postgres Pro Enterprise.
Это изложение может показаться несколько длинным, но без него не будет понятно какую проблему мы решаем и почему выбрано именно такое решение.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>3.1. От кластера до кортежа</h3>
</div>

<div><p class="num">21</p></div>
<div><p>
Итак, основной метод борьбы со сложностью - это классификация.
Ещё лучше, если она является иерархической.
И нам повезло, что Postgres устроен как раз таким способом. 
</p></div>

<div><p class="num">22</p></div>
<div><p>
<!-- https://postgrespro.ru/docs/enterprise/14/creating-cluster?lang=ru -->
На саммом "верхнем" уровне мы имеем кластер БД, то есть некоторую область на диске, которую мы будем использовать.
В SQL применяется термин «кластер каталога».
С точки зрения файловой системы кластер баз данных представляет собой один каталог, в котором будут храниться все данные. 
</p></div>

<div><p class="num"></p></div>
<div>
<img width="800" src="./img/02.svg">
<p class="illustration">Рис. 1 – иерархия кластера</p></div>

<div><p class="num">23</p></div>
<div><p>
Логически кластер БД представляет собой набор баз данных, каждая из которых может состоять из таблиц, индексов и прочих объектов.
В контексте данного изложения нас интересуют только таблицы (в Postgres часто в качестве синонима слова таблица используется слово heap, то есть куча) и частично индексы.
</p></div>

<div><p class="num"></p></div>
<div>
<img width="800" src="./img/03.svg">
<p class="illustration">Рис. 2 – устройство таблицы</p></div>


<div><p class="num">24</p></div>
<div><p>
Таблицы состоят из файлов–сегментов (они же heap files).
Как только размер файла–сегмента исчерпывается, то создаётся новый файл и т.д.
По умолчанию каждый сегмент равен 1 гигабайту, но его размер, конечно, может быть настроен.
Делается это через опцию <code>--with-segsize</code> во время компиляции.
Просмотр размера сегмента на работающем сервере выполняется через настройку <code>segment_size</code>.
</p></div>

<div><p class="num">25</p></div>
<div><p>
Файлы–сегменты хранят данные в постраничном виде, по 8 килобайт.
При этом, размер самой страницы можно менять.
Для этого используется опция <code>--with-blocksize</code> при компиляции.
</p></div>

<div><p class="num"></p></div>
<div>
<img width="800" src="./img/04.svg">
<p class="illustration">Рис. 3 – устройство страницы на диске</p></div>

<div><p class="num">26</p></div>
<div><p>
Про упрощённом представлении страницу можно представить следующим образом.
</p></div>

<div><p class="num"></p></div>
<div>
<img width="800" src="./img/05.svg">
<p class="illustration">Рис. 3.1 – устройство страницы на диске (упрощённое)</p></div>

<div><p class="num">27</p></div>
<div><p>
Условно внутреннее устройство страницы можно разделить на три логических блока: заголовок страницы, массив указателей на кортежи и сами кортежи.
При этом, каждый кортеж неявно имеет дополнительные xmin, xmax и ctid. 
</p></div>

<div><p class="num">28</p></div>
<div><p>
Эти служебные поля можно явно просмотреть, указав в запросе:<br>
<hr>
<pre><code>
postgres=# create table foo(bar int, baz boolean);
CREATE TABLE
postgres=# insert into foo(bar, baz) select val, val % 2 <> 0 from generate_series(1, 10000) as val;
INSERT 0 10000
postgres=# checkpoint;
CHECKPOINT
postgres=# select xmin, xmax, ctid, * from foo limit 4;
 xmin | xmax | ctid  | bar | baz
------+------+-------+-----+-----
  731 |    0 | (0,1) |   1 | t
  731 |    0 | (0,2) |   2 | f
  731 |    0 | (0,3) |   3 | t
  731 |    0 | (0,4) |   4 | f
(4 rows)

postgres=# create extension pageinspect;
CREATE EXTENSION
postgres=# select * from page_header(get_raw_page('foo', 0));
    lsn    | checksum | flags | lower | upыper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 0/19B64D0 |        0 |     4 |   928 |   960 |    8192 |     8192 |       4 |         0
(1 row)

</code></pre>
<!-- <hr> -->
</p></div>

<div><p class="num">29</p></div>
<div><p>
Служебную информацию из заголовка страницы можно просмотреть, воспользовавшись контрибом <code>pageinspect</code>:<br>
<hr>
<pre><code>
postgres=# SELECT oid::regclass AS table, relpages FROM pg_class WHERE relname = 'foo';
 table | relpages
-------+----------
 foo   |       45
(1 row)

postgres=# create extension pageinspect;
CREATE EXTENSION
postgres=# select * from page_header(get_raw_page('foo', 0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 0/19B64D0 |        0 |     4 |   928 |   960 |    8192 |     8192 |       4 |         0
(1 row)

postgres=# select * from page_header(get_raw_page('foo', 44));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 0/1A4F770 |        0 |     4 |   248 |  6400 |    8192 |     8192 |       4 |         0
(1 row)

</code></pre>
<!-- <hr> -->
</p></div>

<div><p class="num">30</p></div>
<div><p>
Также интересно посмотреть на статистику по кортежам, и для этого воспользуемся контрибом <code>pgstattuple</code>:<br>
<hr>
<pre><code>
postgres=# create extension pgstattuple;
CREATE EXTENSION
postgres=# \x
Expanded display is on.
postgres=# SELECT * FROM pgstattuple('foo');
-[ RECORD 1 ]------+-------
table_len          | 368640
tuple_count        | 10000
tuple_len          | 290000
tuple_percent      | 78.67
dead_tuple_count   | 0
dead_tuple_len     | 0
dead_tuple_percent | 0
free_space         | 7380
free_percent       | 2

</code></pre>
<!-- <hr> -->
</p></div>

<div><p class="num">31</p></div>
<div><p>
Получается интересная ситуация: хотя сами данные занимают 5 байт (4 байта на поле типа int и 1 байт на поле boolean), сам кортеж занимает 29 байт.
Тут нет никакой загадки: 24 байта - это служебная информация кортежа и 5 байт самих данных пользователя.
Естественно, это вырожденный случай, и в реальных условиях не часто может встречаться таблица из малого количества полей, но большая по размеру. 
Эту особенность стоит учитывать при проектировании больших баз данных.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>3.2. Переход на 64–х битные счётчики транзакций</h3>
</div>

<div><p class="num">32</p></div>
<div><p>
Теперь давайте посмотрим как изменился формат страницы в Postgres Pro Enterprice при добавлении 64–х битных счётчиков транзакций.
</p></div>

<div><p class="num"></p></div>
<div>
<img width="800" src="./img/06.svg">
<p class="illustration">Рис. 4 – устройство страницы на диске в Postgres Pro Enterprise</p></div>

<div><p class="num">33</p></div>
<div><p>
Видно, что размер кортежей на странице остался такой же, какой был в Postgres.
Для реализации 64–х битных счётчиков транзакций в Postgres Pro Enterprice в конец каждой страницы таблицы (если точнее, то на страницу кучи) добавлена "специальная" область.
Размер её 24 байта.
Подобный механизм не уникален, он используется уже в некоторых индексах.
Видно, что размер кортежей на странице остался такой же, как в Postgres.
Это важно, в смысле того, что страница остаётся в "оригинальном" формате, и переупаковки кортежей при обновлении с Postgres на Postgres Pro Enterprice не требуется.
В самой этой области находится общая информация для всех кортежей на странице:<br>
<hr>
<pre><code>
/*
 * HeapPageSpecialData -- data that stored at the end of each heap page.
 *
 *     pd_xid_base - base value for transaction IDs on page
 *     pd_multi_base - base value for multixact IDs on page
 *     pd_prune_xid - oldest XID among potentially prunable tuples on page.
 *     pd_magic - magic number identifies type of page
 *
 * pd_prune_xid is a hint field that helps determine whether pruning will be
 * useful.  It is currently unused in index pages.
 *
 * pd_xid_base and pd_multi_base are base values for calculation of transaction
 * identifiers from t_xmin and t_xmax in each heap tuple header on the page.
 *
 * pd_magic allows identified an type of object heap page belongs to.
 * Currently, heap page may belong to an regular table heap or sequence heap.
 */
typedef struct HeapPageSpecialData
{
    TransactionId       pd_xid_base;   /* base value for transaction IDs on page */
    TransactionId       pd_multi_base; /* base value for multixact IDs on page */
    ShortTransactionId  pd_prune_xid;  /* oldest prunable XID, or zero if none */
    uint32              pd_magic;      /* magic number identifies type of page */
} HeapPageSpecialData;
</code></pre>
<!-- <hr> -->
</p></div>

<div><p class="num">34</p></div>
<div><p>
Выполним такую же последовательность команд, как в предыдущем разделе:<br>
<hr>
<pre><code>
postgres=# create table foo(bar int, baz boolean);
CREATE TABLE
postgres=# insert into foo(bar, baz) select val, val % 2 <> 0 from generate_series(1, 10000) as val;
INSERT 0 10000
postgres=# checkpoint;
CHECKPOINT
postgres=# select xmin, xmax, ctid, * from foo limit 4;
 xmin | xmax | ctid  | bar | baz
------+------+-------+-----+-----
  753 |    0 | (0,1) |   1 | t
  753 |    0 | (0,2) |   2 | f
  753 |    0 | (0,3) |   3 | t
  753 |    0 | (0,4) |   4 | f
(4 rows)

postgres=# create extension pageinspect;
CREATE EXTENSION
postgres=# select * from page_header(get_raw_page('foo', 0));
    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid
-----------+----------+-------+-------+-------+---------+----------+---------+-----------
 0/182C868 |        0 |     4 |   924 |   936 |    8168 |     8192 |     254 |       750
(1 row)

</code></pre>
<!-- <hr> -->
</p></div>

<div><p class="num">35</p></div>
<div><p>
Легко заметить, что добавилась "специальная область" размером 24 байта.
В рамках заметки нас интересуют только <code>pd_xid_base</code> и <code>pd_multi_base</code>.
При этом, можно отметить, что транзакции и <i>мультитранзакции</i> - это два совершенно разных механизма в Postrges, каждый из них
умеет свой "счётчик", поэтому для них используются две разные базы.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>3.3. Вычисление ксидов для кортежей</h3>
</div>

<div><p class="num">36</p></div>
<div><p>
Теперь необходимо пояснить как происходит вычисление 64–х битных значений полей xmax и xmin для каждого из кортежей на странице.
Это происходит следующим образом:
</p></div>

<div><p class="num"></p></div>
<div>
<img width="800" src="./img/07.svg">
<p class="illustration">Рис. 4 – устройство страницы на диске в Postgres Pro Enterprise</p></div>

<div><p class="num">37</p></div>
<div><p>
В случае, если для транзакции установлен признак мультитранзакции, используется поле <code>pd_multi_base</code>.
Остальные вычисления происходят аналогичным образом.
</p></div>

<div><p class="num">38</p></div>
<div><p>
Внимательный читатель уже хочет спросить: если xmin и xmax в кортеже остались 32–х битные, то получается что на одной странице нельзя разместить
данные с транзакций, отстоящих друг от друга больше, чем на 2^32?
Да, это так.
С одной стороны, для большинства старых кортежей при условии работы автовакуума будет выставлен признак заморозки, то есть для них не будет проверяться само значение xmin.
С другой стороны - мы уже работаем над устранением этого ограничения.
И возможно, что мы сможем от него избавиться в ближайшее время.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>3.4. Дисковое представление страниц отношений</h3>
</div>

<div><p class="num">39</p></div>
<div><p>
Postgres Pro Enterprise размещает на heap страницах (т.е. на страницах таблиц) специальную область, которая называется special.
В ней находится дополнительная информация, называемой "базой", которая позволяет вычислить 64–х битные значения полей xmax и xmin для каждого из кортежей на странице.
Это позволяет соблюсти баланс между увеличением размера хранимой информации и желанием получить 64–х битные транзакции.
</p></div>

<div> <!-- para -->
</div>
<div>
<h2>4. Обновления с Postgres до Postgres Pro Enterprise</h2>
</div>

<div><p class="num">40</p></div>
<div><p>
Учитывая то, что формат страниц кучи меняется незначительно, при этом возникает вопрос: возможно или нет обновление с Postgres до Postgres Pro Enterprise?
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>4.1. Возможно? Да!</h3>
</div>

<div><p class="num">41</p></div>
<div><p>
Да, обновление возможно!
Оно выполняется с помощью стандартной утилиты обновления <code>pg_upgrade</code>.
Далее страницы хипа "лениво" конвертируются в новый формат 64–х битных счётчиков транзакций.
</p></div>

<div> <!-- para -->
</div>
<div>
<h3>4.2. Особенности обновления</h3>
</div>

<div><p class="num">42</p></div>
<div><p>
Первое, что важно знать: после такого обновления текущий счётчик будет 2^32.
Это делается для того, чтобы любая новая транзакция была заведомо старше любой старой (учитывая возможный wraparound).
</p></div>

<div><p class="num">43</p></div>
<div><p>
Вторая особенность: как поступить в случае, если на странице не хватает места?
Что делать, если специальную область не получается разместить на странице даже после удаления "мёртвых" картежей и
последующей переупаковки? В этом случае используется механизм, получивший название "double xmax".
Суть его довольно проста: если мы не можем изменить страницу, тогда и не будем это делать.
Зато xmin в кортежах на такой странице уже не имеет значения, потому что все данные заведомо "заморожены", и 
мы можем смело использовать поле xmin для хранения недостающей части 64–х битного xmax.
</p></div>

<div><p class="num">44</p></div>
<div><p>
Конечно, это довольно поверхностное изложение. 
Настоящий механизм учитывает множество разных ньюансов и особенностей.
Но общая идея именно такова.
</p></div>

<div> <!-- para -->
</div>
<div>
<h2>Выводы</h2>
</div>

<div><p class="num">45</p></div>
<div><p>
В Postgres Pro Enterprice используются 64–х битные счётчики транзакций.
Данная статья описывает базовый механизм их работы, не углубляясь в детали реализации.
</p></div>

<div><p class="num">46</p></div>
<div><p>
Переход на 64–х битные ксиды позволил СУБД Postgres Pro Enterprice эффективно функционировать в системах с высокой транзакционной нагрузкой,
упростив в этом смысле администрирование.
</p></div>

<div> <!-- para -->
</div>
<div>
<h2>Ссылки</h2>
</div>

<div><p class="num">48</p></div>
<div><p>
[1] https://postgrespro.ru/education/books/internals<br>
[2] Рогов Е. В. PostgreSQL изнутри. М.: ДМК Пресс, 2022. 660 с. стр. 77<br>
[3] Рогов Е. В. PostgreSQL изнутри. М.: ДМК Пресс, 2022. 660 с. стр. 54<br>
[4] https://habr.com/ru/company/postgrespro/blog/301238/<br>
[5] https://devcenter.heroku.com/articles/postgresql-concurrency<br>
[6] https://www.interdb.jp/pg/pgsql01.html<br>
[7] https://habr.com/ru/company/postgrespro/blog/337180/<br>
</p></div>

<!-- /grid-container-1-2 -->

<!-- DOCUMENT END -->
</div> <!-- /grid-container -->
</div> <!-- /content -->
</body>
</html>

